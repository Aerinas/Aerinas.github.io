<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香梨椰奶冰糕的甜品屋</title>
    <link>https://aerinas.github.io/post/</link>
    <description>Recent content from 香梨椰奶冰糕的甜品屋</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    
    <managingEditor>703415977@qq.com (香梨椰奶冰糕)</managingEditor>
    <webMaster>703415977@qq.com (香梨椰奶冰糕)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Mon, 15 Mar 2027 11:00:00 -0700</lastBuildDate>
    
    
    <atom:link href="https://aerinas.github.io/post/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>Hello World</title>
      <link>https://aerinas.github.io/post/hello/</link>
      <pubDate>Thu, 25 Sep 2025 11:00:00 -0700</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>https://aerinas.github.io/post/hello/</guid>
      <description>
        <![CDATA[<h1>Hello World</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <p>First post</p>
        
        <hr><p>本文2025-09-25首发于<a href='https://aerinas.github.io/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2027-03-15</p>]]>
      </description>
      
    </item>
    
    

    <item>
      <title>49. Group Anagrams</title>
      <link>https://aerinas.github.io/post/49/</link>
      <pubDate>Mon, 29 Sep 2025 22:00:00 &#43;1000</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>https://aerinas.github.io/post/49/</guid>
      <description>
        <![CDATA[<h1>49. Group Anagrams</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <h2 id="49-字母异位词分组group-anagrams">
<a class="header-anchor" href="#49-%e5%ad%97%e6%af%8d%e5%bc%82%e4%bd%8d%e8%af%8d%e5%88%86%e7%bb%84group-anagrams"></a>
49. 字母异位词分组（Group Anagrams）
</h2><h3 id="-题目描述">
<a class="header-anchor" href="#-%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0"></a>
🔹 题目描述
</h3><p>给定字符串数组 <code>strs</code>，将字母异位词（排序后相同）分到同一组，返回所有分组。</p>
<h3 id="-解题思路你的方案">
<a class="header-anchor" href="#-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af%e4%bd%a0%e7%9a%84%e6%96%b9%e6%a1%88"></a>
🔹 解题思路（你的方案）
</h3><ul>
<li><strong>核心想法：</strong> 对每个字符串复制一份并排序，<strong>排序后的字符串作为哈希键</strong>；把原串追加到该键对应的桶里。</li>
<li><strong>实现步骤：</strong>
<ol>
<li>遍历 <code>strs</code>：
<ul>
<li><code>tempstr = a; sort(tempstr.begin(), tempstr.end());</code></li>
<li><code>dict[tempstr].push_back(a);</code></li>
</ul>
</li>
<li>遍历 <code>dict</code>，把每个桶（<code>value</code>）推入 <code>answer</code>。</li>
</ol>
</li>
<li><strong>结果：</strong> 共享相同“排序键”的字符串被聚到同一组。</li>
</ul>
<h3 id="-代码点评针对你贴的实现">
<a class="header-anchor" href="#-%e4%bb%a3%e7%a0%81%e7%82%b9%e8%af%84%e9%92%88%e5%af%b9%e4%bd%a0%e8%b4%b4%e7%9a%84%e5%ae%9e%e7%8e%b0"></a>
🔹 代码点评（针对你贴的实现）
</h3><ul>
<li>✅ 结构清晰、可读性好，逻辑正确。</li>
<li>✅ 使用 <code>unordered_map&lt;string, vector&lt;string&gt;&gt;</code>，平均时间复杂度更优于 <code>map</code>。</li>
<li>⚠️ <code>cout &lt;&lt; tempstr;</code> 属于调试输出，<strong>提交前请移除</strong>，否则会影响判题输出。</li>
<li>⚠️ 变量 <code>unorderedChars</code> 未使用，建议删除以保持整洁。</li>
<li>⚠️ 遍历 <code>unordered_map</code> 的顺序不稳定，<strong>题目不要求固定顺序</strong>，因此没问题。</li>
</ul>
<h3 id="-c-实现要点与可优化点">
<a class="header-anchor" href="#-c-%e5%ae%9e%e7%8e%b0%e8%a6%81%e7%82%b9%e4%b8%8e%e5%8f%af%e4%bc%98%e5%8c%96%e7%82%b9"></a>
🔹 C++ 实现要点与可优化点
</h3><ul>
<li><strong>减少拷贝：</strong>
<ul>
<li>现在每次都复制 <code>a</code> 到 <code>tempstr</code> 用于排序，这是必要的（不能直接改动 <code>a</code>，否则会丢失原串）。</li>
<li>如果<strong>允许修改输入</strong>并且不再使用 <code>strs</code>，可以<strong>移动原串</strong>进入桶，减少一次字符串拷贝：
<ul>
<li>需注意：你的 for 是 <code>for (auto &amp;a : strs)</code>，<code>std::move(a)</code> 会把 <code>strs</code> 中的元素置空（可接受时再用）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>预分配容量：</strong>
<ul>
<li>在把桶转存到 <code>answer</code> 前，可 <code>answer.reserve(dict.size())</code>，避免动态扩容。</li>
<li>收集结果时可<strong>直接移动桶</strong>以避免拷贝：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">answer</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">:</span> <span class="n">dict</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">));</span> <span class="c1">// 避免复制桶内字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li><strong>时间复杂度优化方向（可选）：</strong>
<ul>
<li>你的做法是 <strong>O(n · L log L)</strong>（n 是字符串个数，L 是均长）。</li>
<li>若改为<strong>26 字母计数作为键</strong>可降到 <strong>O(n · L)</strong>。做法：统计 26 位频次，序列化为键（如 <code>&quot;c0#c1#...#c25&quot;</code>），或用 <code>array&lt;int,26&gt;</code> + 自定义 hash。</li>
</ul>
</li>
<li><strong>小语法点：</strong>
<ul>
<li>已使用 C++17 结构化绑定 <code>for (auto&amp; [key, value] : dict)</code>，👍。</li>
<li>插入时 <code>dict[tempstr].push_back(a);</code> 已自动完成“默认构造桶”的逻辑，惯用且简洁。</li>
</ul>
</li>
</ul>
<h3 id="-复杂度分析">
<a class="header-anchor" href="#-%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90"></a>
🔹 复杂度分析
</h3><ul>
<li><strong>时间：</strong> 排序键方案 <code>O(n · L log L)</code>；计数键可到 <code>O(n · L)</code>。</li>
<li><strong>空间：</strong> <code>O(n · L)</code> 存储哈希表与结果（必需级别）。</li>
</ul>
<h3 id="-总结">
<a class="header-anchor" href="#-%e6%80%bb%e7%bb%93"></a>
🔹 总结
</h3><ul>
<li>本题的关键在于为“异位词等价类”设计一个<strong>稳定、可哈希的代表</strong>（排序键 / 计数键）。</li>
<li>你的实现正确且直观；若追求极致性能，可考虑计数键；若追求减少拷贝，可在<strong>允许修改输入</strong>时使用 <code>std::move</code>，并在收集答案阶段对桶使用移动语义。</li>
<li>提交前清理调试输出与未用变量，给评测一个干净实现。</li>
</ul>
<h3 id="-相关题目">
<a class="header-anchor" href="#-%e7%9b%b8%e5%85%b3%e9%a2%98%e7%9b%ae"></a>
🔹 相关题目
</h3><ul>
<li>
<ol start="242">
<li>有效的字母异位词（判断两串是否为异位词，计数/排序两法）</li>
</ol>
</li>
<li>
<ol start="438">
<li>找到字符串中所有字母异位词（滑动窗口 + 计数）
-（可扩展：支持大写/Unicode 时，计数维度与排序规则需相应调整）</li>
</ol>
</li>
</ul>
        
        <hr><p>本文2025-09-29首发于<a href='https://aerinas.github.io/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2025-09-29</p>]]>
      </description>
      
    </item>
    
    

    <item>
      <title>Post2</title>
      <link>https://aerinas.github.io/post/post2/</link>
      <pubDate>Fri, 26 Sep 2025 10:01:46 &#43;1000</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>https://aerinas.github.io/post/post2/</guid>
      <description>
        <![CDATA[<h1>Post2</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <p>123</p>
        
        <hr><p>本文2025-09-26首发于<a href='https://aerinas.github.io/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2025-09-26</p>]]>
      </description>
      
    </item>
    
  </channel>
</rss>
