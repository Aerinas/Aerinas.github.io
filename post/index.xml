<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>香梨椰奶冰糕的甜品屋</title>
    <link>http://localhost:1313/post/</link>
    <description>Recent content from 香梨椰奶冰糕的甜品屋</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    
    <managingEditor>703415977@qq.com (香梨椰奶冰糕)</managingEditor>
    <webMaster>703415977@qq.com (香梨椰奶冰糕)</webMaster>
    
    <copyright>本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</copyright>
    
    <lastBuildDate>Mon, 15 Mar 2027 11:00:00 -0700</lastBuildDate>
    
    
    <atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss&#43;xml" />
    

    
    

    <item>
      <title>Hello World</title>
      <link>http://localhost:1313/post/hello/</link>
      <pubDate>Thu, 25 Sep 2025 11:00:00 -0700</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>http://localhost:1313/post/hello/</guid>
      <description>
        <![CDATA[<h1>Hello World</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <p>First post</p>
        
        <hr><p>本文2025-09-25首发于<a href='http://localhost:1313/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2027-03-15</p>]]>
      </description>
      
    </item>
    
    

    <item>
      <title>15. 3Sum</title>
      <link>http://localhost:1313/post/15/</link>
      <pubDate>Sat, 04 Oct 2025 16:20:59 &#43;1000</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>http://localhost:1313/post/15/</guid>
      <description>
        <![CDATA[<h1>15. 3Sum</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <h2 id="15-3sum">
<a class="header-anchor" href="#15-3sum"></a>
15. 3Sum
</h2><h3 id="-题目描述">
<a class="header-anchor" href="#-%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0"></a>
🔹 题目描述
</h3><p>给定整数数组 <code>nums</code>，找出所有和为 0 的<strong>不重复</strong>三元组 <code>[a,b,c]</code>，要求：<code>a + b + c = 0</code>。</p>
<h3 id="-解题思路">
<a class="header-anchor" href="#-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af"></a>
🔹 解题思路
</h3><ul>
<li>先对数组排序，外层固定第一个数 <code>nums[i]</code>。</li>
<li>在区间 <code>[i+1, n-1]</code> 用<strong>左右双指针</strong>（<code>j=i+1, k=n-1</code>）寻找 <code>nums[j] + nums[k] = -nums[i]</code>。</li>
<li>根据三数之和 <code>sum</code> 与 0 的比较移动指针：
<ul>
<li><code>sum &lt; 0</code> → <code>j++</code></li>
<li><code>sum &gt; 0</code> → <code>k--</code></li>
<li><code>sum == 0</code> → 记录解；随后 <strong><code>j++</code> 与 <code>k--</code></strong>，并<strong>跳过重复值</strong>。</li>
</ul>
</li>
</ul>
<h3 id="-关键点">
<a class="header-anchor" href="#-%e5%85%b3%e9%94%ae%e7%82%b9"></a>
🔹 关键点
</h3><ul>
<li><strong>去重 1（外层）</strong>：若 <code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>，直接跳过，避免相同首元素重复计算。</li>
<li><strong>去重 2（内层）</strong>：命中一组解后，先同时 <code>++j</code>、<code>--k</code>，再在 <code>j&lt;k</code> 条件下：
<ul>
<li>跳过与前一位置相同的 <code>j</code>：<code>while (j&lt;k &amp;&amp; nums[j]==nums[j-1]) ++j;</code></li>
<li>跳过与后一位置相同的 <code>k</code>：<code>while (j&lt;k &amp;&amp; nums[k]==nums[k+1]) --k;</code></li>
</ul>
</li>
<li><strong>剪枝</strong>：排序后若 <code>nums[i] &gt; 0</code>，后续不可能再有解，可 <code>break</code>。</li>
<li><strong>越界与顺序</strong>：所有“跳重”判断都置于 <code>j&lt;k</code> 保护下，且顺序为<strong>先移动，再跳重</strong>，避免遗漏和越界。</li>
</ul>
<h3 id="-c-实现要点">
<a class="header-anchor" href="#-c-%e5%ae%9e%e7%8e%b0%e8%a6%81%e7%82%b9"></a>
🔹 C++ 实现要点
</h3><ul>
<li>使用 <code>std::sort</code> 排序；双指针在同一数组上原地移动，空间友好。</li>
<li>命中一组解后的顺序应为：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]});</span>
</span></span><span class="line"><span class="cl"><span class="o">++</span><span class="n">j</span><span class="p">;</span> <span class="o">--</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">--</span><span class="n">k</span><span class="p">;</span>
</span></span></code></pre></div></li>
</ul>
        
        <hr><p>本文2025-10-04首发于<a href='http://localhost:1313/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2025-10-04</p>]]>
      </description>
      
    </item>
    
    

    <item>
      <title>1. Two Sum</title>
      <link>http://localhost:1313/post/1/</link>
      <pubDate>Tue, 30 Sep 2025 22:20:00 &#43;1000</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>http://localhost:1313/post/1/</guid>
      <description>
        <![CDATA[<h1>1. Two Sum</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <h2 id="1-two-sum">
<a class="header-anchor" href="#1-two-sum"></a>
1. Two Sum
</h2><h3 id="-题目描述">
<a class="header-anchor" href="#-%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0"></a>
🔹 题目描述
</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的 <strong>两个数的下标</strong>。<br>
可以假设每种输入只会对应一个答案，但数组中同一个元素不能使用两遍。</p>
        
        <hr><p>本文2025-09-30首发于<a href='http://localhost:1313/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2025-09-30</p>]]>
      </description>
      
    </item>
    
    

    <item>
      <title>128. Longest Consecutive Sequence</title>
      <link>http://localhost:1313/post/128/</link>
      <pubDate>Tue, 30 Sep 2025 21:50:00 &#43;1000</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>http://localhost:1313/post/128/</guid>
      <description>
        <![CDATA[<h1>128. Longest Consecutive Sequence</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <h2 id="128-longest-consecutive-sequence">
<a class="header-anchor" href="#128-longest-consecutive-sequence"></a>
128. Longest Consecutive Sequence
</h2><h3 id="-题目描述">
<a class="header-anchor" href="#-%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0"></a>
🔹 题目描述
</h3><p>给定一个未排序的整数数组，找出其中最长的连续元素序列的长度。要求算法时间复杂度为 O(n)。</p>
<h3 id="-解题思路">
<a class="header-anchor" href="#-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af"></a>
🔹 解题思路
</h3><ul>
<li><strong>思路 1（有序集合 / map）：</strong><br>
将所有元素放入 <code>map</code> 或 <code>set</code>，自动排序去重，再扫描判断是否连续。
<ul>
<li>复杂度：O(n log n)（插入有序结构）。</li>
</ul>
</li>
<li><strong>思路 2（哈希集合 O(n)）：</strong>
<ul>
<li>使用 <code>unordered_set</code> 存储所有元素，支持 O(1) 平均查找。</li>
<li>遍历集合，每个数只在它是“序列起点”（即 <code>num-1</code> 不存在）时，才向右扩展统计长度。</li>
<li>保持全局最大值。</li>
</ul>
</li>
</ul>
<h3 id="-关键点">
<a class="header-anchor" href="#-%e5%85%b3%e9%94%ae%e7%82%b9"></a>
🔹 关键点
</h3><ul>
<li><strong>起点判断</strong>：只从“左邻居不存在”的数开始扩展，避免重复计算。</li>
<li><strong>集合存储</strong>：<code>unordered_set</code> 既去重又支持 O(1) 查找。</li>
<li><strong>收尾处理</strong>：每段连续区间结束时更新最大值。</li>
</ul>
<h3 id="-c-实现要点">
<a class="header-anchor" href="#-c-%e5%ae%9e%e7%8e%b0%e8%a6%81%e7%82%b9"></a>
🔹 C++ 实现要点
</h3><ul>
<li><code>unordered_set&lt;int&gt; st(nums.begin(), nums.end());</code> 直接构建哈希集合。</li>
<li>遍历时用 <code>st.count(x)</code> 判断元素是否存在。</li>
<li>变量命名：<code>curr</code> 表示当前数字，<code>len</code> 表示当前连续段长度。</li>
<li>时间复杂度保证 O(n)：每个元素最多访问两次。</li>
</ul>
<h3 id="-复杂度分析">
<a class="header-anchor" href="#-%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90"></a>
🔹 复杂度分析
</h3><ul>
<li><strong>时间复杂度</strong>：O(n)（均摊，哈希查找为 O(1)）</li>
<li><strong>空间复杂度</strong>：O(n)（存储哈希集合）</li>
</ul>
<h3 id="-总结">
<a class="header-anchor" href="#-%e6%80%bb%e7%bb%93"></a>
🔹 总结
</h3><ul>
<li>使用 <code>map/set</code> 可以解，但复杂度为 O(n log n)。</li>
<li>使用 <code>unordered_set</code> 并配合“起点扩展”技巧，能达到 O(n)，符合题意要求。</li>
<li>核心思想是 <strong>避免重复遍历</strong>：每个连续序列只会从起点被遍历一次。</li>
</ul>
<h3 id="-相关题目">
<a class="header-anchor" href="#-%e7%9b%b8%e5%85%b3%e9%a2%98%e7%9b%ae"></a>
🔹 相关题目
</h3><ul>
<li>
<ol start="164">
<li>最大间距（Bucket Sort 思想）</li>
</ol>
</li>
<li>
<ol start="287">
<li>寻找重复数（集合/哈希判重）</li>
</ol>
</li>
<li>剑指 Offer 38. 字符串的排列（需要去重 + 枚举连续）</li>
</ul>
        
        <hr><p>本文2025-09-30首发于<a href='http://localhost:1313/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2025-09-30</p>]]>
      </description>
      
    </item>
    
    

    <item>
      <title>49. Group Anagrams</title>
      <link>http://localhost:1313/post/49/</link>
      <pubDate>Mon, 29 Sep 2025 22:00:00 &#43;1000</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>http://localhost:1313/post/49/</guid>
      <description>
        <![CDATA[<h1>49. Group Anagrams</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <h2 id="49-字母异位词分组group-anagrams">
<a class="header-anchor" href="#49-%e5%ad%97%e6%af%8d%e5%bc%82%e4%bd%8d%e8%af%8d%e5%88%86%e7%bb%84group-anagrams"></a>
49. 字母异位词分组（Group Anagrams）
</h2><h3 id="-题目描述">
<a class="header-anchor" href="#-%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0"></a>
🔹 题目描述
</h3><p>给定字符串数组 <code>strs</code>，将字母异位词（排序后相同）分到同一组，返回所有分组。</p>
<h3 id="-解题思路你的方案">
<a class="header-anchor" href="#-%e8%a7%a3%e9%a2%98%e6%80%9d%e8%b7%af%e4%bd%a0%e7%9a%84%e6%96%b9%e6%a1%88"></a>
🔹 解题思路（你的方案）
</h3><ul>
<li><strong>核心想法：</strong> 对每个字符串复制一份并排序，<strong>排序后的字符串作为哈希键</strong>；把原串追加到该键对应的桶里。</li>
<li><strong>实现步骤：</strong>
<ol>
<li>遍历 <code>strs</code>：
<ul>
<li><code>tempstr = a; sort(tempstr.begin(), tempstr.end());</code></li>
<li><code>dict[tempstr].push_back(a);</code></li>
</ul>
</li>
<li>遍历 <code>dict</code>，把每个桶（<code>value</code>）推入 <code>answer</code>。</li>
</ol>
</li>
<li><strong>结果：</strong> 共享相同“排序键”的字符串被聚到同一组。</li>
</ul>
<h3 id="-代码点评针对你贴的实现">
<a class="header-anchor" href="#-%e4%bb%a3%e7%a0%81%e7%82%b9%e8%af%84%e9%92%88%e5%af%b9%e4%bd%a0%e8%b4%b4%e7%9a%84%e5%ae%9e%e7%8e%b0"></a>
🔹 代码点评（针对你贴的实现）
</h3><ul>
<li>✅ 结构清晰、可读性好，逻辑正确。</li>
<li>✅ 使用 <code>unordered_map&lt;string, vector&lt;string&gt;&gt;</code>，平均时间复杂度更优于 <code>map</code>。</li>
<li>⚠️ <code>cout &lt;&lt; tempstr;</code> 属于调试输出，<strong>提交前请移除</strong>，否则会影响判题输出。</li>
<li>⚠️ 变量 <code>unorderedChars</code> 未使用，建议删除以保持整洁。</li>
<li>⚠️ 遍历 <code>unordered_map</code> 的顺序不稳定，<strong>题目不要求固定顺序</strong>，因此没问题。</li>
</ul>
<h3 id="-c-实现要点与可优化点">
<a class="header-anchor" href="#-c-%e5%ae%9e%e7%8e%b0%e8%a6%81%e7%82%b9%e4%b8%8e%e5%8f%af%e4%bc%98%e5%8c%96%e7%82%b9"></a>
🔹 C++ 实现要点与可优化点
</h3><ul>
<li><strong>减少拷贝：</strong>
<ul>
<li>现在每次都复制 <code>a</code> 到 <code>tempstr</code> 用于排序，这是必要的（不能直接改动 <code>a</code>，否则会丢失原串）。</li>
<li>如果<strong>允许修改输入</strong>并且不再使用 <code>strs</code>，可以<strong>移动原串</strong>进入桶，减少一次字符串拷贝：
<ul>
<li>需注意：你的 for 是 <code>for (auto &amp;a : strs)</code>，<code>std::move(a)</code> 会把 <code>strs</code> 中的元素置空（可接受时再用）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>预分配容量：</strong>
<ul>
<li>在把桶转存到 <code>answer</code> 前，可 <code>answer.reserve(dict.size())</code>，避免动态扩容。</li>
<li>收集结果时可<strong>直接移动桶</strong>以避免拷贝：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">answer</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">dict</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span> <span class="o">:</span> <span class="n">dict</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">value</span><span class="p">));</span> <span class="c1">// 避免复制桶内字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li><strong>时间复杂度优化方向（可选）：</strong>
<ul>
<li>你的做法是 <strong>O(n · L log L)</strong>（n 是字符串个数，L 是均长）。</li>
<li>若改为<strong>26 字母计数作为键</strong>可降到 <strong>O(n · L)</strong>。做法：统计 26 位频次，序列化为键（如 <code>&quot;c0#c1#...#c25&quot;</code>），或用 <code>array&lt;int,26&gt;</code> + 自定义 hash。</li>
</ul>
</li>
<li><strong>小语法点：</strong>
<ul>
<li>已使用 C++17 结构化绑定 <code>for (auto&amp; [key, value] : dict)</code>，👍。</li>
<li>插入时 <code>dict[tempstr].push_back(a);</code> 已自动完成“默认构造桶”的逻辑，惯用且简洁。</li>
</ul>
</li>
</ul>
<h3 id="-复杂度分析">
<a class="header-anchor" href="#-%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90"></a>
🔹 复杂度分析
</h3><ul>
<li><strong>时间：</strong> 排序键方案 <code>O(n · L log L)</code>；计数键可到 <code>O(n · L)</code>。</li>
<li><strong>空间：</strong> <code>O(n · L)</code> 存储哈希表与结果（必需级别）。</li>
</ul>
<h3 id="-总结">
<a class="header-anchor" href="#-%e6%80%bb%e7%bb%93"></a>
🔹 总结
</h3><ul>
<li>本题的关键在于为“异位词等价类”设计一个<strong>稳定、可哈希的代表</strong>（排序键 / 计数键）。</li>
<li>你的实现正确且直观；若追求极致性能，可考虑计数键；若追求减少拷贝，可在<strong>允许修改输入</strong>时使用 <code>std::move</code>，并在收集答案阶段对桶使用移动语义。</li>
<li>提交前清理调试输出与未用变量，给评测一个干净实现。</li>
</ul>
<h3 id="-相关题目">
<a class="header-anchor" href="#-%e7%9b%b8%e5%85%b3%e9%a2%98%e7%9b%ae"></a>
🔹 相关题目
</h3><ul>
<li>
<ol start="242">
<li>有效的字母异位词（判断两串是否为异位词，计数/排序两法）</li>
</ol>
</li>
<li>
<ol start="438">
<li>找到字符串中所有字母异位词（滑动窗口 + 计数）
-（可扩展：支持大写/Unicode 时，计数维度与排序规则需相应调整）</li>
</ol>
</li>
</ul>
        
        <hr><p>本文2025-09-29首发于<a href='http://localhost:1313/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2025-09-29</p>]]>
      </description>
      
    </item>
    
    

    <item>
      <title>Post2</title>
      <link>http://localhost:1313/post/post2/</link>
      <pubDate>Fri, 26 Sep 2025 10:01:46 &#43;1000</pubDate>
      <author>703415977@qq.com (香梨椰奶冰糕)</author>
      <guid>http://localhost:1313/post/post2/</guid>
      <description>
        <![CDATA[<h1>Post2</h1><p>作者：香梨椰奶冰糕（703415977@qq.com）</p>
        
          <p>123</p>
        
        <hr><p>本文2025-09-26首发于<a href='http://localhost:1313/'>香梨椰奶冰糕的甜品屋</a>，最后修改于2025-09-26</p>]]>
      </description>
      
    </item>
    
  </channel>
</rss>
